<h1 id="메모리">메모리</h1>
<p>CPU는 메모리에 올라와 있는 프로그램의 명령어를 실행할 뿐이며, 메모리 계층과 메모리 관리에 대해 알아보자.</p>
<h2 id="메모리-계층">메모리 계층</h2>
<p><img alt="" src="https://velog.velcdn.com/images/jojehuni_9759/post/be31ad3f-ed74-4abc-9584-2e461ba8a931/image.png" /></p>
<ul>
<li>레지스터 : CPU 안에 있는 가장 작은 메모리<ul>
<li>휘발성</li>
<li>속도 가장 빠름</li>
<li>용량 가장 작음</li>
</ul>
</li>
<li>캐시 : L1, L2 캐시를 지칭한다.<ul>
<li>휘발성</li>
<li>속도 빠름</li>
<li>용량 작음</li>
</ul>
</li>
<li>주기억장치 (RAM)<ul>
<li>휘발성</li>
<li>속도 보통</li>
<li>용량 보통</li>
</ul>
</li>
<li>보조기억장치 (HDD, SSD)<ul>
<li>비휘발성</li>
<li>속도 낮음</li>
<li>용량 큼</li>
</ul>
</li>
</ul>
<h3 id="캐시">캐시</h3>
<p>데이터를 미리 복사해놓는 임시 저장소로 빠른 장치와 느린 장치의 속도 차이에 따른 병목 현상을 줄이기 위한 메모리이다.</p>
<p>메모리와 CPU의 속도 차이가 너무 커 중간에 레지스터 계층을 둬 속도 차이를 해결하는데, 이 때 속도 차이를 해결하기 위해서 계층과 계층 사이에 있는 것을 <code>캐싱 계층</code>이라고 한다.</p>
<p>ex) 캐시 메모리 &lt;-&gt; 보조기억장치 사이에 있는 주기억장치 : 보조기억장치의 캐싱 계층</p>
<hr />
<h3 id="지역성의-원리">지역성의 원리</h3>
<blockquote>
<p>캐싱 계층을 두는 것이 아닌 직접 캐시를 설정할 때 : 자주 사용하는 데이터를 기반으로 캐시를 설정해야 한다.</p>
<p>자주 사용하는 데이터라는 개념의 근거? : <code>지역성</code></p>
<ul>
<li>시간 지역성</li>
<li>공간 지역성</li>
</ul>
</blockquote>
<h4 id="시간-지역성">시간 지역성</h4>
<blockquote>
<p>최근 사용한 데이터에 다시 접근하려는 특성</p>
</blockquote>
<p>ex) for 반복문으로 이루어진 코드 안의 변수 i 에 계속 접근하게 될텐데 반복하면서 최근에 사용한 i에 계속 접근해 +1 시켜서 반복하는 것을 생각해볼 수 있다.</p>
<h4 id="공간-지역성">공간 지역성</h4>
<blockquote>
<p>최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성</p>
</blockquote>
<hr />
<h3 id="캐시히트와-캐시미스">캐시히트와 캐시미스</h3>
<blockquote>
<p><strong>캐시히트</strong> : 캐시에서 원하는 데이터를 찾는 것
<strong>캐시미스</strong> : 캐시에 원하는 데이터가 없어 주 메모리에서 찾아오는 것</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/jojehuni_9759/post/48cbc5c6-c34e-4564-ac15-ce14534f7b30/image.png" /></p>
<p>캐시히트를 하게 되면 해당 데이터를 제어장치를 거쳐 가져오게 된다.</p>
<p>캐시히트는 비교적 위치가 가깝고 <code>CPU 내부 버스</code>를 기반으로 작동해 빠르다.</p>
<p>하지만, 캐시미스가 발생하면 <code>시스템 버스</code>를 기반으로 작동해 느리다.</p>
<h4 id="캐시미스의-종류">캐시미스의 종류</h4>
<blockquote>
<ol>
<li><p>컴펄서리 미스(Compulsory Miss) : 처음으로 접근하는 데이터 때문에 발생하는 미스
어떤 데이터가 처음 캐시에 로드될 때 발생</p>
</li>
<li><p>캐피시티 미스(Capacity Miss) : 캐시의 크기가 작아서 발생하는 미스
캐시에 데이터가 너무 많이 들어가면 오래된 데이터가 제거되고, 나중에 다시 그 데이터가 필요하면 미스가 발생</p>
</li>
<li><p>컨플릭트 미스(Conflict Miss) : 캐시 라인에 여러 데이터가 매핑되어 충돌이 발생할 때 생기는 미스
이는 주로 캐시의 매핑 정책과 관련</p>
</li>
</ol>
</blockquote>
<hr />
<h3 id="캐시매핑">캐시매핑</h3>
<blockquote>
<p>캐시매핑 : 캐시가 히트되기 위해 매핑하는 방법</p>
</blockquote>
<ol>
<li><strong>직접 매핑</strong> : 메모리의 특정 블록은 특정 캐시라인에만 매핑할 수 있는 것</li>
<li><strong>연관 매핑</strong> : 순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑하는 것 메모리의 컨텐츠가 캐시의 어느 위치에도 올라갈 수 있는 방법이다.</li>
<li><strong>집합 연관 매핑</strong> : 직접 매핑과 연관 매핑을 합쳐 놓은 것으로, 집합을 나누고 각 집합에 직접 매핑을 사용하는 것</li>
</ol>
<p>캐시 매핑 방식에 대해서 잘 정리해두신 분을 보고 참고하려는 목적으로 링크를 남기고자 한다..</p>
<p><a href="https://velog.io/@ssongjh55/%EC%BA%90%EC%8B%9C%EB%A7%A4%ED%95%91">캐시 매핑 분류</a></p>
<hr />
<p>다음은 웹 브라우저의 캐시를 알아보자.</p>
<h3 id="쿠키">쿠키</h3>
<blockquote>
<p><code>만료기한</code>이 있는 키-값 저장소다.</p>
</blockquote>
<p>이전에 쿠키를 사용했을 때 <code>same site</code> 옵션을 <code>strict</code> 방식으로 사용해야지만 다른 도메인에서 요청했을 때 자동 전송이 되지 않게 제한을 걸 수 있었다.</p>
<p>4KB까지 저장 가능하며, 위에서 말한 것처럼 만료기한도 설정 가능하다.</p>
<p>그리고 document cookie로 쿠키를 볼 수 없게 <code>httponly</code> 옵션 또한 걸어둬야 한다.</p>
<p>보통 서버에서 만료기한을 설정한다.</p>
<hr />
<h3 id="로컬-스토리지">로컬 스토리지</h3>
<blockquote>
<p>만료기한이 없는 키-값 저장소다.</p>
</blockquote>
<p>5MB까지 저장 가능하며, 웹 브라우저를 닫아도 유지된다.</p>
<p>그리고 HTML5를 지원하지 않는 웹 브라우저라면 사용 불가능, 클라이언트에서만 수정 가능하다.</p>
<hr />
<h3 id="세션-스토리지">세션 스토리지</h3>
<blockquote>
<p>만료기한이 없는 키-값 저장소다.</p>
</blockquote>
<p>탭 단위로 세션 스토리지를 생성하고, 탭을 닫을 때 데이터가 삭제된다.</p>
<p>로컬 스토리지와 마찬가지로 5MB까지 저장 가능하고 HTML5를 지원하지 않는 웹 브라우저라면 사용 불가능, 클라이언트에서만 수정 가능하다.</p>
<hr />
<h3 id="데이터베이스의-캐싱-계층">데이터베이스의 캐싱 계층</h3>
<p>메인 데이터베이스 위에 redis를 활용해 캐싱 계층으로 활용하기도 한다.</p>
<p>로그인 기능을 할 때 주로 사용했었다.</p>
<ol>
<li>데이터를 레디스에 쓴다.
2 - 1. 앱은 redis로부터 데이터가 있다면(캐시히트) 읽어온다.
2 - 2. 없다면 (캐시미스) 메인 데이터베이스로부터 가져온다.</li>
</ol>
<hr />
<h2 id="메모리-관리">메모리 관리</h2>
<p>OS의 대표적인 할 일인 메모리 관리에 대해 알아보자.</p>
<h3 id="가상-메모리">가상 메모리</h3>
<blockquote>
<p>실제로 이용 가능한 메모리 자원을 추상화 해 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/jojehuni_9759/post/9c1f7ccd-63ce-4d7a-a3cb-9014d5364fe5/image.png" /></p>
<p>가상 메모리에는 가상 주소와 실제 주소가 매핑돼 있고, 프로세스의 주소 정보가 있는 <code>페이지 테이블</code>로 관리된다.</p>
<p>가상 주소는 <code>메모리관리장치(MMU)</code>에 의해 실제 주소로 변환돼 그로 인해 사용자는 실제 주소를 의식할 필요 없이 프로그램을 구축할 수 있다.</p>
<p>이 때 속도 향상을 위해서는 TLB를 사용하는데</p>
<blockquote>
<p>TLB : 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시
페이지 테이블에 있는 리스트를 보관하여 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있다.</p>
</blockquote>
<hr />
<h4 id="스와핑">스와핑</h4>
<p>가상 메모리는 존재하는데 실제 메모리인 RAM 에는 현재 없는 데이터 or 코드에 접근하는 경우
-&gt; <strong>페이지 폴트 발생</strong></p>
<blockquote>
<p><strong>스와핑</strong> : 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부를 메모리처럼 불러와 쓰는 것</p>
<p><strong>마치 페이지 폴트가 발생하지 않은 것처럼 만든다.</strong></p>
</blockquote>
<hr />
<h4 id="페이지-폴트">페이지 폴트</h4>
<blockquote>
<p>프로세스의 주소 공간에는 존재하지만 RAM에는 없는 데이터에 접근했을 경우에 발생</p>
</blockquote>
<p>위 스와핑, 페이지 폴트는 아래 과정으로 이루어진다.</p>
<ol>
<li>어떤 명령어가 유효한 가상 주소에 접근했는데 <code>페이지</code>가 없을 때</li>
</ol>
<p>-&gt; 트랩 발생 -&gt; OS가 알게 된다.
2. OS는 실제 디스크로부터 사용하지 않은 <code>프레임</code>을 찾는다.
3. 해당 프레임을 실제 메모리에 가져와서 <code>페이지 교체 알고리즘</code>을 기반으로 특정 페이지와 교체한다.</p>
<ul>
<li>이 때 <code>스와핑</code>이 발생<ol start="4">
<li>페이지 테이블을 갱신시킨 후 해당 명령어를 다시 시작</li>
</ol>
</li>
</ul>
<ul>
<li>페이지 : 가상 메모리를 사용하는 최소 크기 단위</li>
<li>프레임 : 실제 메모리를 사용하는 최소 크기 단위</li>
</ul>
<hr />
<h3 id="스레싱">스레싱</h3>
<blockquote>
<p>스레싱 (thrashing) : 메모리의 페이지 폴트율이 높은 것</p>
</blockquote>
<p>스레싱은 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생한다.</p>
<p>페이지 폴트가 일어나면 CPU 이용률이 낮아짐 -&gt; 이용률이 낮아지면 컴퓨터는 CPU 가용성을 더 높이기 위해 더 많은 프로세스를 메모리에 올림 -&gt; 악순환.. (= 스레싱)</p>
<p><strong>해결방법</strong></p>
<ol>
<li>메모리 늘리기</li>
<li>HDD 사용 시 -&gt; SSD로 바꾸기</li>
<li>작업 세트</li>
<li>PFF</li>
</ol>
<p>작업 세트부터 알아보자.</p>
<hr />
<h4 id="작업-세트">작업 세트</h4>
<blockquote>
<p>작업 세트 : 지역성 (프로세스의 과거 사용 이력)을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드하는 것</p>
</blockquote>
<p>미리 메모리에 로드하면 좋은 점</p>
<ul>
<li>탐색에 비용 줄이기</li>
<li>스와핑 줄이기</li>
</ul>
<hr />
<h4 id="pff">PFF</h4>
<blockquote>
<p>PFF (Page Fault Frequency) : 페이지 폴트 빈도를 조절하는 방법으로 상한선, 하한선을 만드는 방법</p>
</blockquote>
<p>상한선에 도달하면 프레임을 늘리고, 하한선에 도달하면 줄이는 방식이다.</p>
<hr />
<h3 id="메모리-할당">메모리 할당</h3>
<p>메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당한다.</p>
<p>이것을 <code>연속 할당</code>, <code>불연속 할당</code>으로 나눈다.</p>
<h4 id="연속-할당">연속 할당</h4>
<blockquote>
<p>메모리에 <strong>연속적으로</strong> 공간을 할당하는 것</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/jojehuni_9759/post/d3e25a4c-209a-4914-a9cf-7df2a2b2149d/image.png" /></p>
<p>위와 같이 순차적으로 공간에 할당할 수 있다.</p>
<p>방식이 2가지가 있는데</p>
<ol>
<li><p><strong>고정 분할 방식</strong> : 메모리를 미리 나누어 관리하는 방식</p>
<ul>
<li>메모리가 미리 나눠져 있어 융통성이 없고, 내부 단편화가 발생한다.</li>
</ul>
</li>
<li><p><strong>가변 분할 방식</strong> : 매 시점 프로그램의 크기에 맞게 메모리를 분할해 사용하는 방식</p>
<ul>
<li>외부 단편화 발생</li>
</ul>
</li>
</ol>
<p>가변 분할 방식의 종류</p>
<ul>
<li>최초 적합 (first fit) : 위쪽 or 아래쪽부터 시작해 홀을 찾으면 바로 할당</li>
<li>최적 적합 (best fit) : 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당</li>
<li>최악 적합 (worst fit) : 프로세스의 크기와 가장 많이 차이나는 홀에 할당</li>
</ul>
<blockquote>
<p><strong>내부 단편화</strong> : 메모리를 나눈 크기보다 프로그램이 작아 들어가지 못하는 공간이 많이 발생하는 현상</p>
<p><strong>외부 단편화</strong> : 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상</p>
<p><strong>홀</strong> : 할당할 수 있는 비어 있는 메모리 공간</p>
</blockquote>
<hr />
<h4 id="불연속-할당">불연속 할당</h4>
<p>현대 운영체제가 쓰는 방법으로 <strong>페이징 기법</strong>이 있다.</p>
<p>추가로 <strong>세그멘테이션</strong>, <strong>페이지드 세그멘테이션</strong> 기법들도 있다.</p>
<h3 id="페이징">페이징</h3>
<blockquote>
<p><strong>페이징 기법</strong> : 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 둬 메모리에 프로그램을 할당하는 것</p>
</blockquote>
<hr />
<h3 id="세그멘테이션">세그멘테이션</h3>
<blockquote>
<p><strong>세그멘테이션</strong> : 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식이다.</p>
</blockquote>
<p>프로세스를 이루는 메모리는 아래 4개 영역으로 나뉜다.</p>
<ul>
<li>코드 영역</li>
<li>데이터 영역</li>
<li>스택 영역</li>
<li>힙 영역</li>
</ul>
<p>세그먼트로 나눈다는 것은 위의 영역에서도 코드와 데이터로 나누거나, 코드 내의 작은 함수와 같은 것들을 세그먼트로 놓고 나눌 수도 있다.</p>
<p><strong>공유와 보안 측면</strong>에서 장점 / <strong>홀 크기가 균일하지 않다</strong>는 단점</p>
<hr />
<h3 id="페이지드-세그멘테이션">페이지드 세그멘테이션</h3>
<blockquote>
<p><strong>페이지드 세그멘테이션</strong> : <strong>의미 단위인 세그먼트로 나누는 방식</strong>으로, 세그멘테이션과는 임의의 길이가 아닌 <strong>동일한 크기의 페이지 단위로 나누는 것</strong>에 차이가 있다.</p>
</blockquote>
<hr />
<h3 id="페이지-교체-알고리즘">페이지 교체 알고리즘</h3>
<p>메모리는 한정돼 있어 스와핑이 많이 일어나는데, 많이 일어나지 않기 위해 설계되는 페이지 교체 알고리즘이 있다.</p>
<p>이러한 알고리즘에 따라 스와핑이 생기는 것이다.</p>
<hr />
<h4 id="fifo-first-in-first-out">FIFO (First In First Out)</h4>
<blockquote>
<p>가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법</p>
</blockquote>
<h4 id="lru-least-recently-used">LRU (Least Recently Used)</h4>
<blockquote>
<p>참조가 가장 오래된 페이지를 바꾼다. <strong>오래된 것</strong>을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 하는 문제점이 있다.</p>
</blockquote>
<h4 id="nurnot-used-recently">NUR(Not Used Recently)</h4>
<p>LRU에서 발전한 알고리즘이다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/jojehuni_9759/post/517fb88a-5157-46be-aaa7-73e5ccfb0247/image.png" /></p>
<p><code>clock 알고리즘</code> 이라고 하며 먼저 0과 1을 가진 비트를 둔다.
1은 최근에 참조되었고, 0은 참조되지 않음을 의미한다.
시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 프로세스를 교체하고, 해당 부분을 1로 바꾸는 알고리즘이다.</p>
<h4 id="lfuleast-frequently-used">LFU(Least Frequently Used)</h4>
<p>가장 참조 횟수가 적은 페이지를 교체한다. 즉, 많이 사용하지 않은 것을 교체한다.</p>